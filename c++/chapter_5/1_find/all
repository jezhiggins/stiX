//
// find   find patterns in text
//
// find pattern
//
// find treads its input a line at a time and writes to its output
// those lines that match the specified text pattern. A text
// pattern is a concatenation of the following elements
//   c        literal character c
//   ?        any character except newline
//   %        beginning of the line
//   $        end of the line (null string before newline)
//   [...]    character class (any of these characters)
//   [^...]   negated character class (all but these characters)
//   *        closure (zero or more occurrences of previous pattern)
//   @c       escaped character (eg @%, @[, @*)
// Special meaning of characters in a text pattern is lost when
// escaped, inside [...] (except @]), or for:
//   %        not at beginning
//   $        not at end
//   *        at beginning
// A character class consists of zero of more of the following
// elements, surrounded by [ and ]:
//   c        literal character c, including [
//   c1-c2    range of characters (digits, lower or upper case letters)
//   ^        negated character class if at beginning
//   @c       escaped character (eg @^ @- @@ @])
// Special meaning of characters in a character class is lost when
// escaped or for:
//   ^        not at beginning
//   -        at beginning or end
// An escape sequence consists of the character @ followed by a
// single character:
//   @n       newline
//   @t       tab
//   @c       c (including @@)
//
// To print line ending in a Pascal keyword or identifier:
//   find [a-zA-Z][a-zA-Z0-9]*$
//

#include "../../lib/arguments.hpp"
#include "find.hpp"
#include <iostream>

int main(int argc, char const* argv[]) {
  auto arguments = stiX::make_arguments(argc, argv);
  if (arguments.size() != 1) {
    std::cout << argv[0] << " pattern" << std::endl;
    return 0;
  }

  stiX::find(std::cin, std::cout, arguments.front());
}#include "char_seq.hpp"

stiX::character_sequence::character_sequence(std::string const& input)
  : input_(input),
    input_length_(input_.size()),
    pos_(0) {
}

bool stiX::character_sequence::is_bol() const {
  return pos_ == 0;
}

bool stiX::character_sequence::is_eol() const {
  return pos_ == input_length_;
}

bool stiX::character_sequence::available() const {
  return (input_length_ != 0) && (pos_ < (input_length_ - 1));
}

char stiX::character_sequence::operator*() const {
  return !is_eol() ? input_[pos_] : char(0);
}

void stiX::character_sequence::advance() {
  if (!is_eol()) ++pos_;
}

void stiX::character_sequence::checkpoint() {
  checkpoint_ = pos_;
}

bool stiX::character_sequence::rewind() {
  if (checkpoint_ == pos_)
    return false;

  --pos_;
  return true;
}


#include "find.hpp"
#include "../../lib/getline.hpp"
#include "pattern_matcher.hpp"

#include <iostream>

void stiX::find(std::istream& in, std::ostream& out, std::string const& pattern) {
  auto matcher = stiX::compile_pattern(pattern);

  while(in) {
    auto line = stiX::getline(in);

    if (matcher.match(line))
      out << line << '\n';
  }
}
#include "matcher.hpp"
#include "char_seq.hpp"
#include <utility>
#include "../../lib/escapes.hpp"
#include "../../lib/dash_range.hpp"

stiX::matcher::matcher(match_fn_with_len match_fn)
  : fn_(std::move(match_fn.first)),
    consume_(match_fn.second) {
}

bool stiX::matcher::match(stiX::character_sequence const& candidate) const {
  return fn_(candidate);
}

bool stiX::matcher::consumes() const {
  return consume_;
}

bool is_any_char(stiX::character_sequence const& c) {
  return !c.is_eol() && (*c != '\n');
}

bool is_bol(stiX::character_sequence const& c) {
  return c.is_bol();
}

bool is_eol(stiX::character_sequence const& c) {
  return c.is_eol();
}

auto is_char_matcher(char target) {
  return [target](stiX::character_sequence const& c) {
    return *c == target;
  };
}

auto is_one_of_matcher(std::string const&targets) {
  return [targets](stiX::character_sequence const& c) {
    return targets.find(*c) != std::string::npos;
  };
}

auto is_not_one_of_matcher(std::string const& targets) {
  return [targets](stiX::character_sequence const& c) {
    return !c.is_eol() && (targets.find(*c) == std::string::npos);
  };
}

static stiX::match_fn_with_len
  make_character_class_matcher(stiX::character_sequence& characters);
static char escape_char(stiX::character_sequence& characters);

static char const match_any_char = '?';
static char const match_beginning_of_line = '%';
static char const match_end_of_line = '$';
static char const start_of_class = '[';
static char const end_of_class = ']';
static char const negate_class = '^';

stiX::match_fn_with_len make_matcher_fn(stiX::character_sequence& characters) {
  char c = *characters;

  if (c == match_any_char)
    return { is_any_char, true };

  if (c == match_beginning_of_line && characters.is_bol())
    return { is_bol, false };

  if (c == match_end_of_line && !characters.available())
    return { is_eol, false };

  if (c == start_of_class)
    return make_character_class_matcher(characters);

  if (c == stiX::Escape)
    c = escape_char(characters);

  return { is_char_matcher(c), true };
}

stiX::match_fn_with_len make_character_class_matcher(stiX::character_sequence& characters) {
  auto subpattern = std::string { };

  characters.advance(); // step past '['
  for (char c = *characters; characters.available() && *characters != end_of_class; characters.advance(), c = *characters) {
    if (c == stiX::Escape)
      c = escape_char(characters);
    subpattern += c;
  }

  auto character_class = std::string { };
  auto subpat = stiX::character_sequence(subpattern);
  bool negated = false;
  if (*subpat == negate_class)
  {
    subpat.advance();
    negated = true;
  }
  for (char c = *subpat; !subpat.is_eol(); subpat.advance(), c = *subpat) {
    if (c == stiX::Dash && subpat.available() && !subpat.is_bol()) {
      char from = character_class.back() + 1;

      subpat.advance();
      char to = *subpat;

      if (stiX::is_dash_range(from, to))
        stiX::expand_dash_range(from, to, std::back_inserter(character_class));
      else
      {
        character_class += stiX::Dash;
        character_class += to;
      }
    }
    else
      character_class += c;
  }

  if (negated)
    return { is_not_one_of_matcher(character_class), true };
  return { is_one_of_matcher(character_class), true };
}

char escape_char(stiX::character_sequence& characters)
{
  if (!characters.available())
    return *characters;

  characters.advance();
  return stiX::expand_escape(*characters);
}

stiX::matcher stiX::make_matcher(stiX::character_sequence& characters) {
  return stiX::matcher(make_matcher_fn(characters));
}
#include "pattern_matcher.hpp"
#include "char_seq.hpp"

stiX::match_stage::match_stage(matcher t)
  : test(std::move(t)), count(match_count::one) {
}

stiX::pattern_matcher::pattern_matcher(match_stages m)
  : m_(std::move(m)){
}

using match_stages_iter = stiX::match_stages::const_iterator;

static bool match_one(stiX::matcher const& matcher, stiX::character_sequence& seq);
static bool match_with_closure(match_stages_iter mbegin, match_stages_iter const& mend, stiX::character_sequence seq);
static bool match_all(match_stages_iter mbegin, match_stages_iter const& mend, stiX::character_sequence seq);
static bool match_all(stiX::match_stages const& matchers, stiX::character_sequence& seq);

bool match_one(stiX::matcher const& matcher, stiX::character_sequence& seq) {
  if (!matcher.match(seq))
    return false;
  if (matcher.consumes())
    seq.advance();
  return true;
}

bool match_with_closure(match_stages_iter mbegin, match_stages_iter const& mend, stiX::character_sequence seq) {
  seq.checkpoint();
  while(match_one(mbegin->test, seq));
  ++mbegin;
  do {
    if (match_all(mbegin, mend, seq))
      return true;
  } while(seq.rewind());

  return false;
}

bool match_all(match_stages_iter mbegin, match_stages_iter const& mend, stiX::character_sequence seq) {
  for(auto m = mbegin; m != mend; ++m) {
    switch (m->count) {
      case stiX::match_count::one:
        if (!match_one(m->test, seq))
          return false;
        break;
      case stiX::match_count::zero_or_more:
        return match_with_closure(m, mend, seq);
    }
  }
  return true;
}

bool match_all(stiX::match_stages const& matchers, stiX::character_sequence& seq) {
  return match_all(matchers.cbegin(), matchers.cend(), seq);
}

bool stiX::pattern_matcher::match(std::string const& line) const {
  bool once = true; // need to try at least once, because even zero length input might match
  for (auto seq = stiX::character_sequence(line); !seq.is_eol() || once; seq.advance(), once = false) {
    if (match_all(m_, seq))
      return true;
  }
  return false;
}

static char const kleene_star = '*';

stiX::pattern_matcher stiX::compile_pattern(std::string const& pattern) {
  auto matches = match_stages { };

  for(auto seq = stiX::character_sequence(pattern); !seq.is_eol(); seq.advance()) {
    if (*seq == kleene_star && !matches.empty()) {
      matches.back().count = match_count::zero_or_more;
      continue;
    }

    matches.emplace_back(make_matcher(seq));
  }

  return pattern_matcher(matches);
}
#include "../../testlib/testlib.hpp"

#include "pattern_matcher.hpp"
#include "matcher.hpp"
#include "char_seq.hpp"
#include "find.hpp"

TEST_CASE("Chapter 5 - character_sequence") {
  SECTION("empty sequence") {
    auto seq = stiX::character_sequence("");
    REQUIRE(seq.is_bol());
    REQUIRE(seq.is_eol());
  }
  SECTION("single character") {
    auto seq = stiX::character_sequence("a");
    REQUIRE(seq.is_bol());
    REQUIRE_FALSE(seq.is_eol());
    REQUIRE(*seq == 'a');

    seq.advance();
    REQUIRE_FALSE(seq.is_bol());
    REQUIRE(seq.is_eol());
  }
  SECTION("longer string") {
    auto seq = stiX::character_sequence("abcde");
    REQUIRE(seq.is_bol());
    REQUIRE_FALSE(seq.is_eol());

    REQUIRE(*seq == 'a');
    seq.advance();
    REQUIRE_FALSE(seq.is_bol());
    REQUIRE_FALSE(seq.is_eol());

    REQUIRE(*seq == 'b');
    seq.advance();
    REQUIRE_FALSE(seq.is_bol());
    REQUIRE_FALSE(seq.is_eol());

    REQUIRE(*seq == 'c');
    seq.advance();
    REQUIRE_FALSE(seq.is_bol());
    REQUIRE_FALSE(seq.is_eol());

    REQUIRE(*seq == 'd');
    seq.advance();
    REQUIRE_FALSE(seq.is_bol());
    REQUIRE_FALSE(seq.is_eol());

    REQUIRE(*seq == 'e');
    seq.advance();
    REQUIRE_FALSE(seq.is_bol());
    REQUIRE(seq.is_eol());
  }
}

stiX::matcher compile(std::string const& input) {
  auto cs = stiX::character_sequence(input);
  return stiX::make_matcher(cs);
}

TEST_CASE("Chapter 5 - find - single matcher") {
  using cs = stiX::character_sequence;

  SECTION("single character match") {
    auto m = compile("a");
    REQUIRE(m.match(cs("a")));
    REQUIRE_FALSE(m.match(cs("b")));
  }
  SECTION("any character match") {
    auto m = compile("?");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("A")));
    REQUIRE(m.match(cs("?")));
    REQUIRE(m.match(cs(" ")));
    REQUIRE_FALSE(m.match(cs("\n")));
  }
  SECTION("% start of line match") {
    auto m = compile("%");

    auto emptyseq = stiX::character_sequence("");
    REQUIRE(m.match(emptyseq));

    auto seq = stiX::character_sequence("abc");
    REQUIRE(m.match(seq));
    seq.advance();
    REQUIRE_FALSE(m.match(seq));
    seq.advance();
    REQUIRE_FALSE(m.match(seq));
  }
  SECTION("$ end of line match") {
    auto m = compile("$");

    auto emptyseq = stiX::character_sequence("");
    REQUIRE(m.match(emptyseq));

    auto seq = stiX::character_sequence("abc");
    REQUIRE_FALSE(m.match(seq));
    seq.advance();
    REQUIRE_FALSE(m.match(seq));
    seq.advance();
    REQUIRE_FALSE(m.match(seq));
    seq.advance();
    REQUIRE(m.match(seq));
  }
  SECTION("[abc] match") {
    auto m = compile("[abc]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("b")));
    REQUIRE(m.match(cs("c")));
    REQUIRE_FALSE(m.match(cs("v")));
  }
  SECTION("[ab-] match") {
    auto m = compile("[ab-]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("b")));
    REQUIRE(m.match(cs("-")));
    REQUIRE_FALSE(m.match(cs("v")));
  }
  SECTION("[-ab] match") {
    auto m = compile("[-ab]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("b")));
    REQUIRE(m.match(cs("-")));
    REQUIRE_FALSE(m.match(cs("v")));
  }
  SECTION("[a-b] match") {
    auto m = compile("[a-b]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("b")));
    REQUIRE_FALSE(m.match(cs("-")));
    REQUIRE_FALSE(m.match(cs("v")));
  }
  SECTION("[a-z] match") {
    auto m = compile("[a-z]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("b")));
    REQUIRE(m.match(cs("c")));
    REQUIRE(m.match(cs("z")));
    REQUIRE_FALSE(m.match(cs("-")));
    REQUIRE_FALSE(m.match(cs("A")));
  }
  SECTION("[a-zA-Z] match") {
    auto m = compile("[a-zA-Z]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("b")));
    REQUIRE(m.match(cs("c")));
    REQUIRE(m.match(cs("z")));
    REQUIRE(m.match(cs("A")));
    REQUIRE(m.match(cs("B")));
    REQUIRE(m.match(cs("C")));
    REQUIRE(m.match(cs("Z")));
    REQUIRE_FALSE(m.match(cs("-")));
    REQUIRE_FALSE(m.match(cs("0")));
  }
  SECTION("[@[@]] match") {
    auto m = compile("[@[@]]");
    REQUIRE(m.match(cs("[")));
    REQUIRE(m.match(cs("]")));
    REQUIRE_FALSE(m.match(cs("-")));
    REQUIRE_FALSE(m.match(cs("0")));
  }
  SECTION("[a-Z] match (invalid dash range)") {
    auto m = compile("[a-Z]");
    REQUIRE(m.match(cs("a")));
    REQUIRE(m.match(cs("-")));
    REQUIRE(m.match(cs("Z")));
    REQUIRE_FALSE(m.match(cs("0")));
    REQUIRE_FALSE(m.match(cs("b")));
  }
  SECTION("[!=-^] match") {
    auto m = compile("[!=-^]");
    REQUIRE(m.match(cs("!")));
    REQUIRE(m.match(cs("=")));
    REQUIRE(m.match(cs("-")));
    REQUIRE(m.match(cs("^")));
    REQUIRE_FALSE(m.match(cs("0")));
    REQUIRE_FALSE(m.match(cs("b")));
  }
  SECTION("[^a-z] match")
  {
    auto m = compile("[^a-z]");
    REQUIRE_FALSE(m.match(cs("a")));
    REQUIRE_FALSE(m.match(cs("b")));
    REQUIRE_FALSE(m.match(cs("c")));
    REQUIRE_FALSE(m.match(cs("z")));
    REQUIRE(m.match(cs("-")));
    REQUIRE(m.match(cs("A")));
  }
}

TEST_CASE("Chapter 5 - find - pattern matcher") {
  using cs = stiX::character_sequence;
  SECTION("simple single-char match") {
    auto p = stiX::compile_pattern("h");
    REQUIRE(p.size() == 1);
    REQUIRE(p.match("hello"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("char sequence match") {
    auto p = stiX::compile_pattern("hello");
    REQUIRE(p.size() == 5);
    REQUIRE(p.match("hello"));
    REQUIRE(p.match("hhhhhhello"));
    REQUIRE(p.match("kellohelloyellow"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("character class match") {
    auto p = stiX::compile_pattern("[helo]");
    REQUIRE(p.size() == 1);
    REQUIRE(p.match("hello"));
    REQUIRE(p.match("hhhhhhello"));
    REQUIRE(p.match("kellohelloyellow"));
    REQUIRE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("character and character class match") {
    auto p = stiX::compile_pattern("h[el][el][el]o");
    REQUIRE(p.size() == 5);
    REQUIRE(p.match("hello"));
    REQUIRE(p.match("hhhhhhello"));
    REQUIRE(p.match("kellohelloyellow"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("char sequence with wild card") {
    auto p = stiX::compile_pattern("he??o");
    REQUIRE(p.size() == 5);
    REQUIRE(p.match("hello"));
    REQUIRE(p.match("hellhello"));
    REQUIRE(p.match("xxxxheXXo"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match("hell"));
    REQUIRE_FALSE(p.match("hel"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("% anchors to start of line") {
    SECTION("%hello") {
      auto p = stiX::compile_pattern("%hello");
      REQUIRE(p.size() == 6);
      REQUIRE(p.match("hello"));
      REQUIRE(p.match("hello friend"));
      REQUIRE_FALSE(p.match("hell"));
      REQUIRE_FALSE(p.match("hhhhhhello"));
      REQUIRE_FALSE(p.match("kellohelloyellow"));
      REQUIRE_FALSE(p.match("goodbye"));
      REQUIRE_FALSE(p.match(""));
    }
    SECTION("%[helo]") {
      auto p = stiX::compile_pattern("%[helo]");
      REQUIRE(p.size() == 2);
      REQUIRE(p.match("hello"));
      REQUIRE(p.match("hello friend"));
      REQUIRE(p.match("hell"));
      REQUIRE(p.match("hhhhhhello"));
      REQUIRE_FALSE(p.match("kellohelloyellow"));
      REQUIRE_FALSE(p.match("goodbye"));
      REQUIRE_FALSE(p.match(""));
    }
  }
  SECTION("% is only special at start of pattern") {
    auto p = stiX::compile_pattern("percent %");
    REQUIRE(p.size() == 9);
    REQUIRE(p.match("percent %"));
    REQUIRE(p.match("percent %!"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("$ anchors to end of line") {
    SECTION("hello$") {
      auto p = stiX::compile_pattern("hello$");
      REQUIRE(p.size() == 6);
      REQUIRE(p.match("hello"));
      REQUIRE(p.match("oh hello"));
      REQUIRE_FALSE(p.match("hell"));
      REQUIRE_FALSE(p.match("hello friend"));
      REQUIRE_FALSE(p.match("kellohelloyellow"));
      REQUIRE_FALSE(p.match("goodbye"));
      REQUIRE_FALSE(p.match(""));
    }
    SECTION("[helo]$") {
      auto p = stiX::compile_pattern("[helo]$");
      REQUIRE(p.size() == 2);
      REQUIRE(p.match("hello"));
      REQUIRE(p.match("oh hello"));
      REQUIRE(p.match("hell"));
      REQUIRE_FALSE(p.match("hello friend"));
      REQUIRE_FALSE(p.match("kellohelloyellow"));
      REQUIRE(p.match("goodbye"));
      REQUIRE_FALSE(p.match(""));
    }
  }
  SECTION("$ is only special at end of pattern") {
    auto p = stiX::compile_pattern("what $ that");
    REQUIRE(p.size() == 11);
    REQUIRE(p.match("oh what $ that proot"));
    REQUIRE(p.match("what $ that"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("%$ matches empty string") {
    auto p = stiX::compile_pattern("%$");
    REQUIRE(p.size() == 2);
    REQUIRE(p.match(""));
    REQUIRE_FALSE(p.match("nope"));
  }
  SECTION("char sequence anchored at both ends") {
    auto p = stiX::compile_pattern("%he??o$");
    REQUIRE(p.size() == 7);
    REQUIRE(p.match("hello"));
    REQUIRE(p.match("heppo"));
    REQUIRE_FALSE(p.match("hell"));
    REQUIRE_FALSE(p.match("hhhhhhello"));
    REQUIRE_FALSE(p.match("kellohelloyellow"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("escape sequence") {
    auto escape_tests = std::vector<std::array<std::string, 2>> {
      { "@", "@" },
      { "@@", "@" },
      { "@%", "%" },
      { "@[", "[" },
      { "@t", "\t" },
      { "@n", "\n" }
    };

    for (auto escape_test : escape_tests) {
      auto escape = escape_test[0];
      auto expected = escape_test[1];
      DYNAMIC_SECTION(escape) {
        auto p = stiX::compile_pattern(escape);
        REQUIRE(p.match(expected));
      }
    }
  }
  SECTION("* by itself") {
    auto p = stiX::compile_pattern("*");
    REQUIRE(p.size() == 1);
    REQUIRE(p.match("a star *"));
    REQUIRE_FALSE(p.match("a hash #"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("hel*o") {
    auto p = stiX::compile_pattern("hel*o");
    REQUIRE(p.size() == 4);
    REQUIRE(p.match("heo"));
    REQUIRE(p.match("helo"));
    REQUIRE(p.match("hello"));
    REQUIRE(p.match("hhhhhhello"));
    REQUIRE(p.match("hhhhhhellllllllo"));
    REQUIRE(p.match("kellohelloyellow"));
    REQUIRE_FALSE(p.match("hep"));
    REQUIRE_FALSE(p.match("help"));
    REQUIRE_FALSE(p.match("hellp"));
    REQUIRE_FALSE(p.match("hhhhhhellp"));
    REQUIRE_FALSE(p.match("hhhhhhellllllllp"));
    REQUIRE_FALSE(p.match("goodbye"));
    REQUIRE_FALSE(p.match(""));
  }
  SECTION("?*") {
    auto p = stiX::compile_pattern("?*");
    REQUIRE(p.size() == 1);
    REQUIRE(p.match("Fruit"));
    REQUIRE(p.match("a"));
    REQUIRE(p.match(""));
  }
  SECTION("?*$") {
    auto p = stiX::compile_pattern("?*$");
    REQUIRE(p.size() == 2);
    REQUIRE(p.match("Fruit"));
    REQUIRE(p.match("a"));
    REQUIRE(p.match(""));
  }
  SECTION("[^0-9]*$") {
    auto p = stiX::compile_pattern("[^0-9]*$");
    REQUIRE(p.size() == 2);
    REQUIRE(p.match("Fruit"));
    REQUIRE(p.match("a"));
    REQUIRE(p.match(""));
    REQUIRE_FALSE(p.match("000"));
  }
  SECTION("%?*") {
    auto p = stiX::compile_pattern("%?*");
    REQUIRE(p.size() == 2);
    REQUIRE(p.match("Fruit"));
    REQUIRE(p.match("a"));
    REQUIRE(p.match(""));
  }
  SECTION("%?*$") {
    auto p = stiX::compile_pattern("%?*$");
    REQUIRE(p.size() == 3);
    REQUIRE(p.match("Fruit"));
    REQUIRE(p.match("a"));
    REQUIRE(p.match(""));
  }
  SECTION("?*b") {
    auto p = stiX::compile_pattern("?*b");
    REQUIRE(p.size() == 2);
    REQUIRE(p.match("Fruitb"));
    REQUIRE(p.match("ab"));
    REQUIRE(p.match("b"));
    REQUIRE_FALSE(p.match("Fruit"));
    REQUIRE_FALSE(p.match("a"));
    REQUIRE_FALSE(p.match(""));
  }
}

void testFind(
  std::string const& input,
  std::string const& expected,
  std::string const& pattern
);

TEST_CASE("Chapter 5 - find") {
  testFind(
    "#include <iostream>\n#include \"local.h\"\nvoid fn(std::istream& in);",
    "#include <iostream>\n#include \"local.h\"\n",
    "%#include");
  testFind(
    "#include <iostream>\n#include \"local.h\"\nvoid fn(std::istream& in);",
    "#include <iostream>\n",
    "%#include *<?*> *");
}

void testFind(
  std::string const& input,
  std::string const& expected,
  std::string const& pattern
) {
  testFilter("find", input, expected,
             [pattern](std::istream& in, std::ostream& out) {
    stiX::find(in, out, pattern);
  }
);
}
#ifndef STICPP_CHAR_SEQ_HPP
#define STICPP_CHAR_SEQ_HPP

#include <string>

namespace stiX {
  class character_sequence {
  public:
    explicit character_sequence(std::string const& input);

    bool is_bol() const;
    bool is_eol() const;
    bool available() const;

    char operator *() const;

    void advance();

    void checkpoint();
    bool rewind();

  private:
    std::string_view const input_;
    size_t const input_length_;
    size_t pos_;
    size_t checkpoint_;
  };
}

#endif //STICPP_CHAR_SEQ_HPP
#ifndef STICPP_FIND_HPP
#define STICPP_FIND_HPP

#include <ios>
#include <string>

namespace stiX {
  void find(std::istream& in, std::ostream& out, std::string const& pattern);
}

#endif //STICPP_FIND_HPP
#ifndef STICPP_MATCHER_HPP
#define STICPP_MATCHER_HPP

#include <string>
#include <functional>

namespace stiX {
  class character_sequence;
  using match_fn = std::function<bool(character_sequence const&)>;
  using match_fn_with_len = std::pair<match_fn, bool>;

  class matcher {
  public:
    bool match(character_sequence const& candidate) const;
    bool consumes() const;

  private:
    explicit matcher(match_fn_with_len fn);

    match_fn fn_;
    bool consume_;

    friend matcher make_matcher(stiX::character_sequence&);
  };

  matcher make_matcher(stiX::character_sequence& characters);
}

#endif //STICPP_MATCHER_HPP
#ifndef STICPP_PATTERN_MATCHER_HPP
#define STICPP_PATTERN_MATCHER_HPP

#include "matcher.hpp"
#include <vector>

namespace stiX {
  enum class match_count {
    one,
    zero_or_more
  };
  struct match_stage {
    matcher test;
    match_count count;

    match_stage() = delete;
    explicit match_stage(matcher t);
  };

  using match_stages = std::vector<match_stage>;

  class pattern_matcher {
  public:
    bool match(std::string const& line) const;
    size_t size() const { return m_.size(); }

  private:
    explicit pattern_matcher(match_stages m);

    match_stages const m_;

    friend pattern_matcher compile_pattern(std::string const&);
  };

  pattern_matcher compile_pattern(std::string const& pattern);
}
#endif //STICPP_PATTERN_MATCHER_HPP
